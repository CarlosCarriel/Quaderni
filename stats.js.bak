// Aletheia rev_1.4 - Asistente Local
// Componente: ANALÍTICA (El Observador)
// Función: Visualización de KPIs, latencia y distribución de uso (Dual Interface Analytics)

const defaultData = {
    totalRequests: 0,
    completedRequests: 0,
    failedRequests: 0,
    totalLatency: 0,
    maxLatency: 0,
    minLatency: Infinity,
    requests: [],
    roleStats: {}
};

// ============ VARIABLES GLOBALES ============
let latencyChartInstance = null;
let rolesChartInstance = null;

// ============ CARGA INICIAL ============
function loadData() {
    chrome.storage.local.get(['tde_stats'], (result) => {
        const stats = result.tde_stats || defaultData;
        console.log('[DASHBOARD] Datos cargados:', stats);
        updateKPIs(stats);
    });
}

// ============ LISTENER EN TIEMPO REAL ============
chrome.storage.onChanged.addListener((changes, namespace) => {
    if (namespace === 'local' && changes.tde_stats) {
        console.log('[DASHBOARD] Datos actualizados en tiempo real');
        updateKPIs(changes.tde_stats.newValue || defaultData);
    }
});

// ============ ACTUALIZAR TODO ============
function updateKPIs(stats) {
    // 1. KPIs numéricos
    const totalReqs = stats.totalRequests || 0;
    const completedReqs = stats.completedRequests || 0;
    const failedReqs = stats.failedRequests || 0;
    const totalLatency = stats.totalLatency || 0;
    const maxLatency = stats.maxLatency && stats.maxLatency !== Infinity ? stats.maxLatency : 0;
    
    // Evitar división por cero
    const successRate = totalReqs > 0 ? ((completedReqs / totalReqs) * 100).toFixed(1) : '--';
    const avgLatency = completedReqs > 0 ? (totalLatency / completedReqs).toFixed(0) : '--';
    
    // Actualizar DOM de forma segura
    const setSafe = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    
    setSafe('totalRequests', totalReqs);
    setSafe('completedRequests', completedReqs);
    setSafe('failedRequests', failedReqs);
    setSafe('successRate', successRate + '%');
    setSafe('avgLatency', avgLatency + 'ms');
    setSafe('maxLatency', maxLatency + 'ms');
    setSafe('lastUpdate', 'Última sinc: ' + new Date().toLocaleTimeString('es-ES'));
    
    // 2. Tabla Historial
    updateTable(stats);
    
    // 3. Gráficos
    updateCharts(stats);
}

// ============ TABLA HISTORIAL ============
function updateTable(stats) {
    const tbody = document.getElementById('historyTable');
    if (!tbody) return;
    
    const requests = stats.requests ? [...stats.requests].reverse() : [];
    
    if (requests.length === 0) {
        tbody.innerHTML = `<tr><td colspan="4" style="text-align: center; padding: 20px; color: #666;">Sin actividad reciente</td></tr>`;
        return;
    }
    
    // Tomar solo los últimos 20 para no saturar el DOM
    tbody.innerHTML = requests.slice(0, 20).map(req => {
        const date = req.date || new Date(req.timestamp).toLocaleDateString('es-CL');
        const time = req.time || new Date(req.timestamp).toLocaleTimeString('es-CL');
        const estado = req.success ? '✅ Éxito' : '❌ Error';
        const category = req.categoria || req.mode || 'unknown';
        const concepto = req.concepto || 'N/A';
        const latency = req.latency || 0;

        return `<tr>
            <td>${category}</td>
            <td>${concepto}</td>
            <td>${latency}ms</td>
            <td>${date}</td>
            <td>${time}</td>
            <td>${estado}</td>
        </tr>`;
    }).join('');
}

// ============ GRÁFICOS CON CHART.JS ============
function updateCharts(stats) {
    if (typeof Chart === 'undefined') {
        console.warn('[DASHBOARD] Chart.js no cargado');
        return;
    }
    
    try {
        updateLatencyChart(stats);
        updateRolesChart(stats);
    } catch (e) {
        console.error('[DASHBOARD] Error actualizando gráficos:', e);
    }
}

function updateLatencyChart(stats) {
    const ctx = document.getElementById('latencyChart');
    if (!ctx) return;
    
    const recent = stats.requests ? stats.requests.slice(-30) : [];
    const labels = recent.map((_, i) => i + 1);
    const data = recent.map(r => r.latency || 0);
    
    if (latencyChartInstance) {
        latencyChartInstance.data.labels = labels;
        latencyChartInstance.data.datasets[0].data = data;
        latencyChartInstance.update();
    } else {
        latencyChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Latencia (ms)',
                    data: data,
                    borderColor: '#00ff00',
                    backgroundColor: 'rgba(0, 255, 0, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true,
                    pointRadius: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: { color: '#333' },
                        ticks: { color: '#888' }
                    }
                }
            }
        });
    }
}

function updateRolesChart(stats) {
    const ctx = document.getElementById('rolesChart');
    if (!ctx) return;
    
    const roleStats = stats.roleStats || {};
    const labels = Object.keys(roleStats).map(k => k.toUpperCase());
    const data = Object.values(roleStats).map(v => v.count || 0);
    
    if (labels.length === 0) {
        labels.push('Sin Datos');
        data.push(1);
    }
    
    if (rolesChartInstance) {
        rolesChartInstance.data.labels = labels;
        rolesChartInstance.data.datasets[0].data = data;
        rolesChartInstance.update();
    } else {
        rolesChartInstance = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: ['#667eea', '#764ba2', '#4facfe', '#43e97b', '#fa709a', '#fee140'],
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: { color: '#aaa', boxWidth: 10 }
                    }
                }
            }
        });
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// EXPORTACIÓN CSV AVANZADA - PARA ANÁLISIS CUANTITATIVO Y CUALITATIVO
// ═══════════════════════════════════════════════════════════════════════════════

document.addEventListener('DOMContentLoaded', () => {
    // Botón Descargar CSV
    const btnCsv = document.getElementById('export-csv');
    if (btnCsv) {
        btnCsv.addEventListener('click', exportToCSV);
    }
    
    // Botón Descargar JSON
    const btnJson = document.getElementById('export-json');
    if (btnJson) {
        btnJson.addEventListener('click', exportToJSON);
    }
    
    // Botón Importar
    const btnImport = document.getElementById('import-stats');
    if (btnImport) {
        btnImport.addEventListener('click', () => {
            document.getElementById('file-input').click();
        });
    }
    
    // Input file para importar
    const fileInput = document.getElementById('file-input');
    if (fileInput) {
        fileInput.addEventListener('change', importStats);
    }
    
    // Cargar datos iniciales
    loadData();
});

// ============ EXPORTACIÓN A CSV ✅ MEJORADA ============
function exportToCSV() {
    chrome.storage.local.get(['tde_stats'], (result) => {
        const stats = result.tde_stats;
        if (!stats || !stats.requests || stats.requests.length === 0) {
            showMessage('❌ No hay datos para exportar', 'error');
            return;
        }
        
        // ✅ AHORA INCLUYE INPUT Y OUTPUT COMPLETOS
        const headers = [
            'Interfaz',
            'Versión',
            'Categoría',
            'Concepto',
            'Input (Consulta)',
            'Resultado (Output)',
            'Fecha',
            'Hora',
            'Latencia (ms)',
            'Latencia (s)',
            'Estado'
        ];
        
        // Generar filas con INPUT y OUTPUT
        const rows = stats.requests.map(req => {
            const latenciaMs = req.latency || 0;
            const latenciaS = req.latencySeconds || (latenciaMs / 1000).toFixed(3).replace('.', ',');
            const estado = req.success ? 'Éxito' : 'Error';
            
            return [
                req.interfaz || 'Unknown',   // Ahora dinámico (Popup/Overlay)
                req.version || '1.4',        // Ahora dinámico
                req.categoria || 'unknown',
                req.concepto || 'N/A',
                req.input || 'N/A',          // Input completo
                req.output || 'N/A',         // Output completo
                req.date || new Date(req.timestamp).toLocaleDateString('es-CL'),
                req.time || new Date(req.timestamp).toLocaleTimeString('es-CL'),
                latenciaMs,
                latenciaS,                   //
                estado
            ];
        });
        
        // Construir CSV
        let csv = headers.map(h => `"${h}"`).join(',') + '\n';
        rows.forEach(row => {
            csv += row.map(cell => {
                // Escapar comillas en valores que las contengan
                const escaped = String(cell).replace(/"/g, '""');
                return `"${escaped}"`;
            }).join(',') + '\n';
        });
        
        // Descargar
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `tde_stats_${new Date().toISOString().split('T')[0]}.csv`;
        link.click();
        
        showMessage('✅ CSV descargado exitosamente (' + stats.requests.length + ' registros)', 'success');
        console.log('[EXPORT] CSV con input/output:', stats.requests.length);
    });
}

// ============ EXPORTACIÓN A JSON ============
function exportToJSON() {
    chrome.storage.local.get(['tde_stats'], (result) => {
        const stats = result.tde_stats;
        if (!stats) {
            showMessage('❌ No hay datos para exportar', 'error');
            return;
        }
        
        const json = JSON.stringify(stats, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `tde_stats_backup_${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        
        showMessage('✅ JSON descargado exitosamente', 'success');
    });
}

// ============ IMPORTACIÓN DE DATOS ============
function importStats(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
        try {
            const data = JSON.parse(event.target.result);
            chrome.storage.local.set({ tde_stats: data }, () => {
                showMessage('✅ Datos importados correctamente', 'success');
                loadData();
                console.log('[IMPORT] ' + data.requests.length + ' registros restaurados');
            });
        } catch (err) {
            showMessage('❌ Error: archivo JSON inválido', 'error');
            console.error('[IMPORT] Error:', err);
        }
    };
    reader.readAsText(file);
    e.target.value = '';
}

// ============ UTILIDAD: MENSAJES ============
function showMessage(message, type) {
    const el = document.getElementById('status-message');
    if (!el) return;
    
    el.textContent = message;
    el.className = 'status-message status-' + type;
    
    setTimeout(() => {
        el.className = 'status-message';
    }, 3000);
}

// ============ INICIALIZACIÓN ============
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadData);
} else {
    loadData();
}